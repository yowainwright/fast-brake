---
title: Troubleshooting & FAQ
description: Common issues, debugging tips, and frequently asked questions for fast-brake
---

## Frequently Asked Questions

### What is fast-brake?

fast-brake is an ES feature detection library that analyzes JavaScript code to identify ECMAScript features and verify compatibility with target ES versions. It uses a two-phase detection system that can be faster than traditional AST parsers for its intended service to brake fast!

### Why is fast-brake faster than other tools?

fast-brake uses a unique **two-phase detection system**:
1. **Phase 1**: Lightning-fast regex pattern matching for initial feature detection
2. **Phase 2**: Intelligent tokenizer validation for accurate detection

This approach avoids the overhead of full AST parsing while maintaining 99.9% accuracy.

### When should I use quick mode vs full mode?

**Quick Mode** (`{ quick: true }`):
- ✅ **Faster** than full mode (~0.013ms per file)
- ✅ Perfect for **development builds** and **hot reloading**
- ⚠️ Pattern-based detection without tokenizer validation
- ✅ Use when speed is critical

**Full Mode** (default):
- ✅ **High accuracy** with tokenizer validation
- ✅ **Still 2x faster** than AST parsers (~0.055ms per file)
- ✅ **Recommended** for production builds and CI/CD
- ✅ Use when accuracy is critical

### Does fast-brake work with TypeScript?

Yes! fast-brake works with TypeScript code and includes full TypeScript definitions. It analyzes the JavaScript syntax patterns regardless of whether the code is in `.js` or `.ts` files.

### What ES versions are supported?

fast-brake supports **ES5 through ES2025** with comprehensive coverage:
- **ES2015**: Arrow functions, classes, template literals, let/const, destructuring, etc.
- **ES2016**: Exponentiation operator (**)
- **ES2017**: Async/await
- **ES2018**: Async iteration, rest/spread properties
- **ES2019**: Array.flat(), Array.flatMap()
- **ES2020**: Optional chaining (?.), nullish coalescing (??), BigInt
- **ES2021**: Logical assignment (||=, &&=, ??=), numeric separators
- **ES2022**: Private fields (#), static blocks, Array.at(), Object.hasOwn()
- **ES2023**: Array.findLast(), Array.toReversed(), Array.toSorted(), hashbang (#!)
- **ES2024**: RegExp v flag, Array.fromAsync(), Promise.withResolvers, Object.groupBy()
- **ES2025**: Temporal API, Set methods (intersection, union, difference, etc.)

### Can I extend fast-brake with custom features?

Yes! fast-brake is designed to be extensible. You can create custom detectors and add your own feature patterns. See the [Advanced Features](/advanced-features) documentation for examples.

## Common Issues

### Quick Mode Detection Characteristics

**Problem:** Quick mode detects ES features in strings or comments.

```javascript
// This code is actually ES5 compatible
const code = `
  var message = "This => looks like an arrow function";
  // This => comment also looks suspicious
`;

const features = detect(code, { quick: true });
console.log(features); // May show arrow_functions
```

**Solution:** Use full mode for accurate results:

```javascript
const features = detect(code, { quick: false }); // default
console.log(features); // [] - correctly identifies as ES5
```

**When to use each mode:**
- **Quick mode**: Development builds, hot reloading, when speed matters most
- **Full mode**: Production builds, CI/CD, when accuracy is critical

### Unexpected Feature Detection

**Problem:** fast-brake detects features you don't think are there.

**Solution:** Use the detailed output to understand what was detected:

```javascript
const features = detect(code);
features.forEach(feature => {
  console.log(`Feature: ${feature.name}`);
  console.log(`Version: ${feature.version}`);
  console.log(`Location: line ${feature.line}, column ${feature.column}`);
  console.log(`Snippet: ${feature.snippet}`);
  console.log('---');
});
```

**Common causes:**
- Template literals (backticks) in regular strings
- Arrow function syntax in regex patterns
- ES features in code comments

### Performance Issues

**Problem:** fast-brake seems slower than expected.

**Solutions:**

1. **Use quick mode for development:**
```javascript
// Development - prioritize speed
const features = detect(code, { quick: true });
```

2. **Reuse detector instances:**
```javascript
import { getDetector } from 'fast-brake';

const detector = getDetector(); // Singleton
const results = files.map(file => detector.detect(file.content));
```

3. **Process files in batches:**
```javascript
// Instead of processing all files at once
const batchSize = 100;
for (let i = 0; i < files.length; i += batchSize) {
  const batch = files.slice(i, i + batchSize);
  const results = batch.map(file => detect(file.content));
  // Process results...
}
```

### Memory Usage Issues

**Problem:** High memory usage when processing large codebases.

**Solution:** Use streaming processing:

```javascript
async function* processLargeCodebase(files) {
  const detector = getDetector();
  
  for (const file of files) {
    // Process one file at a time
    const result = detector.detect(file.content, { quick: true });
    
    // Yield minimal data
    yield {
      path: file.path,
      featureCount: result.length,
      minVersion: getMinimumESVersion(file.content, { quick: true })
    };
  }
}

// Usage
for await (const result of processLargeCodebase(files)) {
  console.log(result);
}
```

### TypeScript Import Issues

**Problem:** Cannot import fast-brake in TypeScript.

```typescript
// Error: Cannot find module 'fast-brake'
import { detect } from 'fast-brake';
```

**Solutions:**

1. **Install type definitions (if needed):**
```bash
npm install --save-dev @types/fast-brake
```

2. **Use require syntax:**
```typescript
const { detect } = require('fast-brake');
```

3. **Add to tsconfig.json:**
```json
{
  "compilerOptions": {
    "moduleResolution": "node",
    "esModuleInterop": true
  }
}
```

### Build Tool Integration Issues

**Problem:** fast-brake doesn't work in webpack/rollup/vite.

**Solution:** Ensure proper configuration:

**Webpack:**
```javascript
// webpack.config.js
module.exports = {
  resolve: {
    fallback: {
      "fs": false,
      "path": false
    }
  }
};
```

**Vite:**
```javascript
// vite.config.js
export default {
  define: {
    global: 'globalThis'
  }
};
```

**Rollup:**
```javascript
// rollup.config.js
import { nodeResolve } from '@rollup/plugin-node-resolve';

export default {
  plugins: [
    nodeResolve({
      preferBuiltins: false
    })
  ]
};
```

## Debugging

### Enable Debug Mode

For detailed information about what fast-brake is doing:

```javascript
// Set environment variable
process.env.DEBUG = 'fast-brake*';

// Or use custom logging
import { detect } from 'fast-brake';

function debugDetection(code, options) {
  console.log('Input code length:', code.length);
  console.log('Options:', options);
  
  const start = performance.now();
  const features = detect(code, options);
  const duration = performance.now() - start;
  
  console.log('Features found:', features.length);
  console.log('Detection time:', duration.toFixed(3), 'ms');
  console.log('Features:', features.map(f => f.name));
  
  return features;
}
```

### Tokenizer Debugging

To understand how the tokenizer processes your code:

```javascript
import { Tokenizer } from 'fast-brake/tokenizer';

function debugTokenization(code) {
  const tokenizer = new Tokenizer(code);
  const allTokens = tokenizer.tokenize();
  const codeTokens = tokenizer.getCodeTokens();
  
  console.log('=== Tokenization Debug ===');
  console.log(`Total tokens: ${allTokens.length}`);
  console.log(`Code tokens: ${codeTokens.length}`);
  console.log(`Filtered out: ${allTokens.length - codeTokens.length}`);
  
  // Show what was filtered out
  const filtered = allTokens.filter(t => 
    !codeTokens.some(ct => ct.start === t.start)
  );
  
  console.log('\nFiltered tokens (strings/comments):');
  filtered.forEach(token => {
    console.log(`  ${token.type}: "${token.value}" at line ${token.line}`);
  });
}

// Usage
debugTokenization(`
  const arrow = () => {};
  const str = "This => is not an arrow function";
  // This => is also not an arrow function
`);
```

### Performance Profiling

To identify performance bottlenecks:

```javascript
function profileDetection(code, iterations = 1000) {
  console.log('=== Performance Profile ===');
  
  // Warm up
  for (let i = 0; i < 10; i++) {
    detect(code, { quick: true });
    detect(code, { quick: false });
  }
  
  // Profile quick mode
  const quickStart = performance.now();
  for (let i = 0; i < iterations; i++) {
    detect(code, { quick: true });
  }
  const quickTime = performance.now() - quickStart;
  
  // Profile full mode
  const fullStart = performance.now();
  for (let i = 0; i < iterations; i++) {
    detect(code, { quick: false });
  }
  const fullTime = performance.now() - fullStart;
  
  console.log(`Quick mode: ${(quickTime / iterations).toFixed(3)}ms per call`);
  console.log(`Full mode: ${(fullTime / iterations).toFixed(3)}ms per call`);
  console.log(`Speed difference: ${(fullTime / quickTime).toFixed(1)}x`);
  
  // Memory usage
  const memUsage = process.memoryUsage();
  console.log(`Memory: ${Math.round(memUsage.heapUsed / 1024 / 1024)}MB`);
}
```

## Error Messages

### "ES feature requires X but target is Y"

**Meaning:** The code contains a feature that requires a newer ES version than your target.

**Example:**
```
ES feature "arrow_functions" requires es2015 but target is es5 at line 1:11
```

**Solutions:**
1. **Update target version:**
```javascript
check(code, { target: 'es2015' }); // Instead of 'es5'
```

2. **Transpile the code:**
```javascript
// Use Babel or similar to convert to target version
const transpiledCode = babel.transform(code, {
  presets: [['@babel/preset-env', { targets: 'es5' }]]
});
```

3. **Use polyfills:**
```javascript
// Add polyfills for missing features
import 'core-js/features/array/includes';
```

### "Cannot read property 'X' of undefined"

**Meaning:** Internal error, usually due to malformed input.

**Solutions:**
1. **Validate input:**
```javascript
if (typeof code !== 'string' || code.length === 0) {
  throw new Error('Code must be a non-empty string');
}
```

2. **Use try-catch:**
```javascript
try {
  const features = detect(code, options);
} catch (error) {
  console.error('Detection failed:', error.message);
  // Fallback to quick mode or return empty array
}
```

### "Maximum call stack size exceeded"

**Meaning:** Usually caused by extremely large files or infinite recursion.

**Solutions:**
1. **Process in chunks:**
```javascript
function detectLargeFile(code, chunkSize = 10000) {
  const chunks = [];
  for (let i = 0; i < code.length; i += chunkSize) {
    chunks.push(code.slice(i, i + chunkSize));
  }
  
  return chunks.flatMap(chunk => detect(chunk, { quick: true }));
}
```

2. **Use quick mode:**
```javascript
// Quick mode is less likely to cause stack overflow
const features = detect(code, { quick: true });
```

## Best Practices

### 1. Choose the Right Mode

```javascript
// Development builds - speed matters
const devFeatures = detect(code, { quick: true });

// Production builds - accuracy matters
const prodFeatures = detect(code, { quick: false });

// CI/CD - fail fast on incompatibility
try {
  fastBrake(code, { target: 'es2018', throwOnFirst: true });
} catch (error) {
  console.error('Build failed:', error.message);
  process.exit(1);
}
```

### 2. Reuse Detector Instances

```javascript
// Good - reuse singleton
const detector = getDetector();
const results = files.map(file => detector.detect(file.content));

// Bad - creates new instances
const results = files.map(file => detect(file.content));
```

### 3. Handle Errors Gracefully

```javascript
function robustDetection(code, options) {
  try {
    return detect(code, { ...options, quick: false });
  } catch (error) {
    console.warn('Full mode failed, falling back to quick mode');
    try {
      return detect(code, { ...options, quick: true });
    } catch (quickError) {
      console.error('Both modes failed:', quickError.message);
      return [];
    }
  }
}
```

### 4. Monitor Performance

```javascript
function monitoredDetection(code, options) {
  const start = performance.now();
  const features = detect(code, options);
  const duration = performance.now() - start;
  
  if (duration > 10) { // Log slow detections
    console.warn(`Slow detection: ${duration.toFixed(2)}ms for ${code.length} chars`);
  }
  
  return features;
}
```

## Getting Help

### Resources

- **GitHub Issues**: [Report bugs and request features](https://github.com/yowainwright/fast-brake/issues)
- **Discussions**: [Ask questions and share ideas](https://github.com/yowainwright/fast-brake/discussions)
- **Documentation**: [Complete API reference](/api-reference)
- **Examples**: [Advanced usage patterns](/advanced-features)

### Before Filing an Issue

1. **Update to latest version:**
```bash
npm update fast-brake
```

2. **Check existing issues:**
Search for similar problems in the GitHub issues.

3. **Create minimal reproduction:**
```javascript
// Minimal example that reproduces the issue
const { detect } = require('fast-brake');

const code = `/* your problematic code here */`;
const result = detect(code, { target: 'es5' });
console.log(result);
```

4. **Include environment info:**
- Node.js version: `node --version`
- fast-brake version: `npm list fast-brake`
- Operating system
- Build tool (if applicable)

### Issue Template

When reporting issues, include:

```markdown
**Environment:**
- Node.js version: 
- fast-brake version: 
- Operating system: 
- Build tool: 

**Expected behavior:**
What you expected to happen

**Actual behavior:**
What actually happened

**Code to reproduce:**
```javascript
// Minimal code that reproduces the issue
```

**Error message (if any):**
```
Full error message and stack trace
```

**Additional context:**
Any other relevant information
```

## Migration Guide

### From Other ES Detection Tools

If you're migrating from other tools:

1. **From ESLint parsers:**
```javascript
// Before (ESLint)
const { parse } = require('@babel/parser');
const ast = parse(code);
// Complex AST traversal...

// After (fast-brake)
const { detect } = require('fast-brake');
const features = detect(code);
```

2. **From Babel parser:**
```javascript
// Before (Babel)
const babel = require('@babel/core');
const result = babel.transform(code, { code: false });
// Check AST for features...

// After (fast-brake)
const { getMinimumESVersion } = require('fast-brake');
const minVersion = getMinimumESVersion(code);
```

3. **From Acorn parser:**
```javascript
// Before (Acorn)
const acorn = require('acorn');
const ast = acorn.parse(code, { ecmaVersion: 2022 });
// Walk AST...

// After (fast-brake)
const { check } = require('fast-brake');
const isCompatible = check(code, { target: 'es2022' });
```

### Performance Comparison

| Tool | 1000 Files | Memory |
|------|------------|---------|
| **fast-brake (Quick)** | **13ms** | **4MB** |
| **fast-brake (Full)** | **55ms** | **4MB** |
| Babel Parser | ~100ms | ~15MB |
| ESLint Parser | ~120ms | ~18MB |
| Acorn Parser | ~80ms | ~12MB |

The migration to fast-brake typically results in significant performance improvements while maintaining or improving accuracy.